#!/usr/bin/env bash

# Cody - Self-Modifying AI Development Assistant
# Complete version with system prompt integration and all functions working
# Usage: ./cody

# Configuration
GEMMA_ENDPOINT="http://192.168.1.45:1234"
OLLAMA_ENDPOINT="http://127.0.0.1:11434"
MODEL_NAME="mistralai/codestral-22b-v0.1"
MEMORY_FILE="$HOME/.cody_global_memory"
HISTORY_FILE="$HOME/.cody_history"
WORK_DIR="$(pwd)"
SYSTEM_PROMPT=""
MAX_BACKUPS=5

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
GRAY='\033[0;37m'
WHITE='\033[1;37m'
NC='\033[0m'

# Icons
CHECKMARK="‚úì"
CROSS="‚úó"
ROBOT="ü§ñ"
ROCKET_ICON="üöÄ"
GEAR="‚öôÔ∏è"
LIGHTNING="‚ö°"
TARGET="üéØ"

# Load system prompt from file
load_system_prompt() {
    if [ -f "$WORK_DIR/cody_system.txt" ]; then
        SYSTEM_PROMPT=$(cat "$WORK_DIR/cody_system.txt")
        echo -e "${GREEN}‚úì Loaded system prompt: cody_system.txt${NC}"
    elif [ -f "$HOME/.cody_system_prompt" ]; then
        SYSTEM_PROMPT=$(cat "$HOME/.cody_system_prompt")
        echo -e "${GREEN}‚úì Loaded system prompt: ~/.cody_system_prompt${NC}"
    else
        SYSTEM_PROMPT="You are Cody, a self-modifying AI development assistant created by Mark Hubrich. You execute actions decisively instead of just suggesting them. When asked to do something, you analyze, plan, and then act. You can modify your own code, manage files, and interact with the system as needed. Be helpful, safe, and concise."
        echo -e "${YELLOW}‚ö†Ô∏è Using default system prompt${NC}"
    fi
}

# Manage backup files - keep only MAX_BACKUPS
manage_backups() {
    local backup_pattern="$0.backup.*"
    local backup_files=()
    while IFS= read -r -d '' file; do
        backup_files+=("$file")
    done < <(find "$(dirname "$0")" -maxdepth 1 -type f -name "$(basename "$backup_pattern")" -print0 | sort -rz)
    if [ "${#backup_files[@]}" -gt "$MAX_BACKUPS" ]; then
        echo -e "${BLUE}Managing backups (keeping $MAX_BACKUPS most recent)${NC}"
        for ((i=MAX_BACKUPS; i<${#backup_files[@]}; i++)); do
            echo -e "${GRAY}Removing old backup: ${backup_files[i]##*/}${NC}"
            rm -f "${backup_files[i]}"
        done
    fi
}

# Load saved model preference
load_model_preference() {
    if [ -f "$HOME/.cody_model" ]; then
        MODEL_NAME=$(cat "$HOME/.cody_model")
    fi
}

# Fetch available models
fetch_available_models() {
    AVAILABLE_MODELS=()
    local resp
    resp=$(curl -s "$GEMMA_ENDPOINT/v1/models" 2>/dev/null)
    if [ -n "$resp" ]; then
        mapfile -t AVAILABLE_MODELS < <(echo "$resp" | jq -r '..|.id? // empty' | sort -u)
    fi
}

# Detect Ollama
detect_ollama() {
    curl -s "$OLLAMA_ENDPOINT/v1/models" >/dev/null 2>&1
}

# Select endpoint
select_endpoint() {
    local endpoints=("$GEMMA_ENDPOINT")
    local names=("LM Studio ($GEMMA_ENDPOINT)")

    if detect_ollama; then
        endpoints+=("$OLLAMA_ENDPOINT")
        names+=("Ollama ($OLLAMA_ENDPOINT)")
    fi

    if [ "${#endpoints[@]}" -gt 1 ]; then
        echo -e "${BLUE}Available servers:${NC}"
        local i=1
        for name in "${names[@]}"; do
            echo -e "  ${YELLOW}${i}.${NC} $name"
            ((i++))
        done
        echo

        local choice
        read -e -p "$(echo -e "${GREEN}Select server (1-${#endpoints[@]}) or Enter for default [1]: ${NC}")" choice
        if [[ $choice =~ ^[0-9]+$ ]] && [ "$choice" -ge 1 ] && [ "$choice" -le ${#endpoints[@]} ]; then
            GEMMA_ENDPOINT="${endpoints[$((choice-1))]}"
        fi
    fi

    echo -e "${GREEN}‚úì Using endpoint: $GEMMA_ENDPOINT${NC}"
}

# Setup readline
setup_readline() {
    set -o emacs
    trap 'print_header' WINCH

    if [ -f "$HISTORY_FILE" ]; then
        while IFS= read -r line; do
            history -s "$line"
        done < "$HISTORY_FILE"
    fi

    bind 'set completion-ignore-case on'
    bind 'set show-all-if-ambiguous on'
    bind '"\e[A": history-search-backward'
    bind '"\e[B": history-search-forward'
    bind '"\C-a": beginning-of-line'
    bind '"\C-e": end-of-line'
    bind '"\C-k": kill-line'
    bind '"\C-u": unix-line-discard'
    bind '"\C-w": unix-word-rubout'
}

# Enhanced input
read_input_enhanced() {
    local input
    IFS= read -e -r input

    if [[ -n "$input" && "$input" != " "* ]]; then
        history -s "$input"
        echo "$input" >> "$HISTORY_FILE"

        if [ -f "$HISTORY_FILE" ] && (( $(wc -l < "$HISTORY_FILE") > 1000 )); then
            tail -n 1000 "$HISTORY_FILE" > "$HISTORY_FILE.tmp" && mv "$HISTORY_FILE.tmp" "$HISTORY_FILE"
        fi
    fi

    echo "$input"
}

# Model selection
select_model() {
    fetch_available_models

    if [ "${#AVAILABLE_MODELS[@]}" -eq 0 ]; then
        echo -e "${RED}No models available${NC}"
        return 1
    fi

    echo -e "${BLUE}ü§ñ Available Models:${NC}"
    local i=1
    for model in "${AVAILABLE_MODELS[@]}"; do
        if [ "$model" = "$MODEL_NAME" ]; then
            echo -e "  ${YELLOW}${i}.${NC} ${GREEN}${model} (current)${NC}"
        else
            echo -e "  ${YELLOW}${i}.${NC} ${model}"
        fi
        ((i++))
    done
    echo

    local choice
    read -e -p "$(echo -e "${GREEN}Select model (1-${#AVAILABLE_MODELS[@]}) or Enter for current: ${NC}")" choice

    if [[ $choice =~ ^[0-9]+$ ]] && [ "$choice" -ge 1 ] && [ "$choice" -le ${#AVAILABLE_MODELS[@]} ]; then
        MODEL_NAME="${AVAILABLE_MODELS[$((choice-1))]}"
        echo -e "${GREEN}‚úì Switched to: $MODEL_NAME${NC}"
        echo "$MODEL_NAME" > "$HOME/.cody_model"
    fi
}

# Header with proper word wrapping
print_header() {
    clear
    local term_width
    term_width=$(tput cols 2>/dev/null || echo 80)

    local top_border="‚ï≠"
    for ((i=1; i<term_width-1; i++)); do
        top_border+="‚îÄ"
    done
    top_border+="‚ïÆ"

    local bottom_border="‚ï∞"
    for ((i=1; i<term_width-1; i++)); do
        bottom_border+="‚îÄ"
    done
    bottom_border+="‚ïØ"

    local title="ü§ñ Self-Modifying Cody"
    local subtitle="AI Development Assistant by Mark Hubrich"
    local title_padding=$(( (term_width - ${#title} - 2) / 2 ))
    local subtitle_padding=$(( (term_width - ${#subtitle} - 2) / 2 ))

    echo -e "${CYAN}$top_border${NC}"

    printf "${CYAN}‚îÇ${NC}"
    printf "%*s" $title_padding ""
    printf "${WHITE}%s${NC}" "$title"
    printf "%*s" $((term_width - title_padding - ${#title} - 2)) ""
    printf "${CYAN}‚îÇ${NC}\n"

    printf "${CYAN}‚îÇ${NC}"
    printf "%*s" $subtitle_padding ""
    printf "${GRAY}%s${NC}" "$subtitle"
    printf "%*s" $((term_width - subtitle_padding - ${#subtitle} - 2)) ""
    printf "${CYAN}‚îÇ${NC}\n"

    echo -e "${CYAN}$bottom_border${NC}"
    echo
    echo -e "${GRAY}Commands:${NC}"
    echo -e "  ${BLUE}/create${NC} <filename> <description>   ${GRAY}Create new file${NC}"
    echo -e "  ${BLUE}/edit${NC} <filename>                  ${GRAY}Edit file${NC}"
    echo -e "  ${BLUE}/run${NC} <filename>                   ${GRAY}Execute file${NC}"
    echo -e "  ${BLUE}/explain${NC} <filename>               ${GRAY}Explain code${NC}"
    echo -e "  ${BLUE}/fix${NC} <filename> <issue>           ${GRAY}Fix code${NC}"
    echo -e "  ${BLUE}/files${NC}                            ${GRAY}List files${NC}"
    echo -e "  ${BLUE}/exec${NC} <command>                   ${GRAY}Execute shell command${NC}"
    echo -e "  ${BLUE}/selfmod${NC} <description>            ${GRAY}Modify myself${NC}"
    echo -e "  ${BLUE}/reload${NC}                           ${GRAY}Reload system prompt${NC}"
    echo -e "  ${BLUE}/model${NC} | ${BLUE}/clear${NC} | ${BLUE}/help${NC} | ${BLUE}/exit${NC}"
    echo
    echo -e "${CYAN}Model:${NC} ${MODEL_NAME}"
    echo -e "${CYAN}Directory:${NC} ${WORK_DIR}"

    # System prompt with proper word wrapping
    echo -e "${CYAN}System Prompt:${NC}"
    if [ -n "$SYSTEM_PROMPT" ]; then
        # Extract first 2 lines of system prompt for display
        local prompt_preview
        prompt_preview=$(echo "$SYSTEM_PROMPT" | head -n 2 | fold -w $((term_width - 4)) -s)
        echo "$prompt_preview" | while IFS= read -r line; do
            echo -e "${GRAY}  $line${NC}"
        done

        # Show if there's more content
        local line_count
        line_count=$(echo "$SYSTEM_PROMPT" | wc -l)
        if [ "$line_count" -gt 2 ]; then
            echo -e "${GRAY}  ... (${line_count} total lines)${NC}"
        fi
    else
        echo -e "${GRAY}  No system prompt loaded${NC}"
    fi

    echo
    echo -e "${CYAN}Powers:${NC} ${GRAY}Self-Modification ${GEAR} Command Execution ${LIGHTNING} File Operations${NC}"

    local separator=""
    for ((i=0; i<term_width; i++)); do
        separator+="‚îÄ"
    done
    echo -e "${GRAY}$separator${NC}"
    echo
}

# Typing animation
show_typing() {
    local message="$1"
    echo -e -n "${BLUE}${message}${NC}"
    for i in {1..3}; do
        sleep 0.2
        echo -n "."
    done
    echo
}

# Project context
get_project_context() {
    local context="Project: $WORK_DIR\n"
    local file_count=0
    (cd "$WORK_DIR" || return
    for file in *; do
        if [ -f "$file" ] && [[ ! "$file" =~ ^cody ]] && [ ${#file} -lt 50 ]; then
            local lines
            lines=$(wc -l < "$file" 2>/dev/null || echo "0")
            if [ "$lines" -lt 200 ]; then
                context="$context- $file ($lines lines)\n"
                ((file_count++))
            fi
        fi
    done
    context="$context\nFiles: $file_count\n"
    echo -e "$context")
}

# AI API call with system prompt
call_gemma() {
    local prompt="$1"
    local custom_system_prompt="${2:-$SYSTEM_PROMPT}"
    local temperature="${3:-0.7}"

    local context
    context=$(get_project_context)
    local full_prompt="$context\n\nUser: $prompt"

    local escaped_prompt
    escaped_prompt=$(echo "$full_prompt" | jq -Rs .)
    local escaped_system
    escaped_system=$(echo "$custom_system_prompt" | jq -Rs .)

    local messages="[{\"role\": \"system\", \"content\": $escaped_system}, {\"role\": \"user\", \"content\": $escaped_prompt}]"

    local response
    response=$(curl -s -X POST "$GEMMA_ENDPOINT/v1/chat/completions" \
        -H "Content-Type: application/json" \
        -d "{
            \"model\": \"$MODEL_NAME\",
            \"messages\": $messages,
            \"temperature\": $temperature,
            \"max_tokens\": 4000
        }" 2>/dev/null)

    if [ -n "$response" ]; then
        local error
        error=$(echo "$response" | jq -r '.error.message // empty' 2>/dev/null)
        if [ -n "$error" ]; then
            echo -e "${RED}API Error: $error${NC}" >&2
            return 1
        fi

        echo "$response" | jq -r '.choices[0].message.content // empty' 2>/dev/null
    fi
}

# Extract code blocks
extract_code() {
    local response="$1"
    if echo "$response" | grep -q '```'; then
        echo "$response" | sed -n '/```/,/```/p' | sed '1d;$d'
    else
        echo "$response"
    fi
}

# Format output
format_output() {
    local text="$1"
    local prefix="${2:-}"
    echo "$text" | fold -w 80 -s | sed "s/^/$prefix/"
}

# Save to memory
save_to_memory() {
    local user_input="$1"
    local response="$2"
    local timestamp
    timestamp=$(date '+%Y-%m-%d %H:%M:%S')

    echo "[$timestamp] User: $user_input" >> "$MEMORY_FILE"
    echo "[$timestamp] Cody: $response" >> "$MEMORY_FILE"
    echo "---" >> "$MEMORY_FILE"

    if [ -f "$MEMORY_FILE" ] && (( $(wc -l < "$MEMORY_FILE") > 400 )); then
        tail -n 400 "$MEMORY_FILE" > "$MEMORY_FILE.tmp" && mv "$MEMORY_FILE.tmp" "$MEMORY_FILE"
    fi
}

# COMMAND EXECUTION ENGINE
execute_command() {
    local command="$1"
    local auto_confirm="${2:-false}"

    echo -e "${BLUE}${LIGHTNING} Executing: ${WHITE}$command${NC}"

    # Improved Safety check
    if [[ "$command" =~ (^|[[:space:]])(rm[[:space:]]+-rf|sudo|chmod[[:space:]]+777|:>|>|>>|:>|/dev/|/dev/null|mkfs|dd[[:space:]]) ]]; then
        echo -e "${RED}‚ö†Ô∏è  Dangerous command blocked${NC}"
        return 1
    fi

    # Confirm
    if [[ "$auto_confirm" != "true" ]]; then
        echo -e -n "${YELLOW}Execute? (y/N): ${NC}"
        local confirm
        read -r confirm
        if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
            echo -e "${GRAY}Cancelled${NC}"
            return 1
        fi
    fi

    echo -e "${GRAY}‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ${NC}"
    (cd "$WORK_DIR" && eval "$command")
    local exit_code=$?
    echo -e "${GRAY}‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ${NC}"

    if [ $exit_code -eq 0 ]; then
        echo -e "${GREEN}‚úì Success${NC}"
    else
        echo -e "${RED}‚úó Failed (exit code: $exit_code)${NC}"
    fi

    return $exit_code
}

# ... (rest of your code remains unchanged but make sure to quote all variable expansions in commands and paths, and use safe subshells for directory changes as demonstrated above) ...
