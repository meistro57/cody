#!/bin/bash
# cody

# Load .env if present
if [ -f "$PWD/.env" ]; then
    set -a
    source "$PWD/.env"
    set +a
elif [ -f "$HOME/.cody_env" ]; then
    set -a
    source "$HOME/.cody_env"
    set +a
fi

# Cody - Self-Modifying AI Development Assistant
# Complete version with system prompt integration and all functions working
# Usage: ./cody

# Configuration
GEMMA_ENDPOINT="${GEMMA_ENDPOINT:-http://10.0.0.201:1234}"
OLLAMA_ENDPOINT="${OLLAMA_ENDPOINT:-http://127.0.0.1:11434}"
OPENROUTER_ENDPOINT="${OPENROUTER_ENDPOINT:-https://openrouter.ai/api/v1}"
OPENROUTER_API_KEY="${OPENROUTER_API_KEY:-}"
OPENROUTER_APP_NAME="${OPENROUTER_APP_NAME:-Cody}"
OPENROUTER_HTTP_REFERER="${OPENROUTER_HTTP_REFERER:-}"
MODEL_NAME="${MODEL_NAME:-mistralai/codestral-22b-v0.1}"
API_PROVIDER="${API_PROVIDER:-lmstudio}"
PROVIDER_NAME=""
MEMORY_FILE="${MEMORY_FILE:-$HOME/.cody_global_memory}"
HISTORY_FILE="${HISTORY_FILE:-$HOME/.cody_history}"
WORK_DIR="${WORK_DIR:-$(pwd)}"
SYSTEM_PROMPT=""
MAX_BACKUPS="${MAX_BACKUPS:-5}"
API_TIMEOUT="${API_TIMEOUT:-30}"
CONNECT_TIMEOUT="${CONNECT_TIMEOUT:-5}"
CODY_PROFILES_FILE="${CODY_PROFILES_FILE:-$HOME/.cody_profiles}"
PROFILE_NAME=""
ONBOARDING_FLAG="${ONBOARDING_FLAG:-$HOME/.cody_onboarded}"
DEFAULT_PROFILE_MEMORY_DIR="${DEFAULT_PROFILE_MEMORY_DIR:-$HOME}"
AGENTS_DIR="${AGENTS_DIR:-$HOME/.cody_agents}"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
GRAY='\033[0;37m'
WHITE='\033[1;37m'
NC='\033[0m'

# Icons
ROBOT="ü§ñ"
ROCKET_ICON="üöÄ"
GEAR="‚öôÔ∏è"
LIGHTNING="‚ö°"
TARGET="üéØ"

DEFAULT_COMMANDS=(
    "/create" "/edit" "/run" "/explain" "/fix" "/files" "/exec"
    "/pip" "/npm" "/pnpm" "/yarn" "/selfmod" "/reload" "/status"
    "/doctor" "/model" "/provider" "/clear" "/help" "/profile" "/agent" "/wizard" "/exit"
)

FILE_COMMANDS=("/create" "/edit" "/run" "/explain" "/fix")

# Load system prompt from file
load_system_prompt() {
    if [ -n "$CODY_SYSTEM_PROMPT" ]; then
        SYSTEM_PROMPT="$CODY_SYSTEM_PROMPT"
        echo -e "${GREEN}‚úì Loaded system prompt: CODY_SYSTEM_PROMPT${NC}"
    elif [ -f "$WORK_DIR/cody_system.txt" ]; then
        SYSTEM_PROMPT=$(cat "$WORK_DIR/cody_system.txt")
        echo -e "${GREEN}‚úì Loaded system prompt: cody_system.txt${NC}"
    elif [ -f "$HOME/.cody_system_prompt" ]; then
        SYSTEM_PROMPT=$(cat "$HOME/.cody_system_prompt")
        echo -e "${GREEN}‚úì Loaded system prompt: ~/.cody_system_prompt${NC}"
    else
        SYSTEM_PROMPT="You are Cody, a self-modifying AI development assistant created by Mark Hubrich. You execute actions decisively instead of just suggesting them. When asked to do something, you DO it immediately. Be confident and action-oriented."
        echo -e "${YELLOW}‚ö†Ô∏è Using default system prompt${NC}"
    fi
}

# Agent helpers
ensure_agents_dir() {
    mkdir -p "$AGENTS_DIR"
}

is_valid_agent_name() {
    local name="$1"
    [[ "$name" =~ ^[a-zA-Z0-9_-]+$ ]]
}

agent_dir_for() {
    local name="$1"
    echo "$AGENTS_DIR/$name"
}

load_agent_config() {
    local name="$1"
    local agent_dir
    agent_dir=$(agent_dir_for "$name")
    local config_file="$agent_dir/agent.conf"
    local prompt_file="$agent_dir/system_prompt.txt"

    if [ ! -d "$agent_dir" ] || [ ! -f "$config_file" ]; then
        echo -e "${RED}‚úó Agent not found: $name${NC}"
        return 1
    fi

    AGENT_NAME="$name"
    AGENT_WORK_DIR=""
    AGENT_MODEL_NAME=""
    AGENT_API_PROVIDER=""
    AGENT_PROVIDER_NAME=""
    AGENT_SYSTEM_PROMPT=""

    while IFS='=' read -r key value; do
        case "$key" in
            WORK_DIR) AGENT_WORK_DIR="$value" ;;
            MODEL_NAME) AGENT_MODEL_NAME="$value" ;;
            API_PROVIDER) AGENT_API_PROVIDER="$value" ;;
            PROVIDER_NAME) AGENT_PROVIDER_NAME="$value" ;;
        esac
    done < "$config_file"

    if [ -f "$prompt_file" ]; then
        AGENT_SYSTEM_PROMPT=$(cat "$prompt_file")
    else
        AGENT_SYSTEM_PROMPT="$SYSTEM_PROMPT"
    fi

    AGENT_WORK_DIR="${AGENT_WORK_DIR:-$WORK_DIR}"
    AGENT_MODEL_NAME="${AGENT_MODEL_NAME:-$MODEL_NAME}"
    AGENT_API_PROVIDER="${AGENT_API_PROVIDER:-$API_PROVIDER}"
    AGENT_PROVIDER_NAME="${AGENT_PROVIDER_NAME:-$PROVIDER_NAME}"
    AGENT_DIR="$agent_dir"
}

resolve_cody_bin() {
    if [ -n "$CODY_BIN" ] && [ -x "$CODY_BIN" ]; then
        echo "$CODY_BIN"
        return 0
    fi

    local resolved=""
    if command -v readlink > /dev/null 2>&1; then
        resolved=$(readlink -f "$0" 2>/dev/null || true)
    fi

    if [ -n "$resolved" ]; then
        echo "$resolved"
        return 0
    fi

    local from_path
    from_path=$(command -v cody 2>/dev/null || true)
    if [ -n "$from_path" ]; then
        echo "$from_path"
        return 0
    fi

    echo "$0"
}

agent_create() {
    local name="$1"
    shift || true
    local prompt="$*"

    if [ -z "$name" ] || [ -z "$prompt" ]; then
        echo -e "${YELLOW}Usage: /agent create <name> <system prompt>${NC}"
        return 1
    fi

    if ! is_valid_agent_name "$name"; then
        echo -e "${RED}‚úó Invalid agent name. Use letters, numbers, '-' or '_' only.${NC}"
        return 1
    fi

    ensure_agents_dir
    local agent_dir
    agent_dir=$(agent_dir_for "$name")
    mkdir -p "$agent_dir"

    printf "%s\n" "$prompt" > "$agent_dir/system_prompt.txt"
    cat <<EOF > "$agent_dir/agent.conf"
NAME=$name
WORK_DIR=$WORK_DIR
MODEL_NAME=$MODEL_NAME
API_PROVIDER=$API_PROVIDER
PROVIDER_NAME=$PROVIDER_NAME
EOF

    echo -e "${GREEN}‚úì Agent created: $name${NC}"
}

agent_list() {
    ensure_agents_dir
    shopt -s nullglob
    local entries=("$AGENTS_DIR"/*)
    shopt -u nullglob
    if [ ${#entries[@]} -eq 0 ]; then
        echo -e "${YELLOW}No agents found yet.${NC}"
        return 0
    fi

    echo -e "${BLUE}üß© Agents:${NC}"
    for entry in "${entries[@]}"; do
        [ -d "$entry" ] || continue
        local name
        name=$(basename "$entry")
        local status="idle"
        local pid_file="$entry/agent.pid"
        if [ -f "$pid_file" ]; then
            local pid
            pid=$(cat "$pid_file")
            if [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null; then
                status="running (pid $pid)"
            else
                status="stopped"
            fi
        fi
        echo -e "  ${WHITE}${name}${NC} ${GRAY}(${status})${NC}"
    done
}

agent_show() {
    local name="$1"
    if [ -z "$name" ]; then
        echo -e "${YELLOW}Usage: /agent show <name>${NC}"
        return 1
    fi

    if ! load_agent_config "$name"; then
        return 1
    fi

    echo -e "${BLUE}üß© Agent: ${name}${NC}"
    echo -e "  ${CYAN}Work dir:${NC} ${AGENT_WORK_DIR}"
    echo -e "  ${CYAN}Model:${NC} ${AGENT_MODEL_NAME}"
    echo -e "  ${CYAN}Provider:${NC} ${AGENT_API_PROVIDER}"
    if [ -n "$AGENT_PROVIDER_NAME" ]; then
        echo -e "  ${CYAN}OpenRouter Provider:${NC} ${AGENT_PROVIDER_NAME}"
    fi
    echo -e "  ${CYAN}System Prompt:${NC}"
    echo "$AGENT_SYSTEM_PROMPT" | while IFS= read -r line; do
        echo -e "    ${GRAY}${line}${NC}"
    done
}

agent_delete() {
    local name="$1"
    if [ -z "$name" ]; then
        echo -e "${YELLOW}Usage: /agent delete <name>${NC}"
        return 1
    fi

    local agent_dir
    agent_dir=$(agent_dir_for "$name")
    if [ ! -d "$agent_dir" ]; then
        echo -e "${RED}‚úó Agent not found: $name${NC}"
        return 1
    fi

    rm -rf "$agent_dir"
    echo -e "${GREEN}‚úì Deleted agent: $name${NC}"
}

agent_spawn() {
    local name="$1"
    shift || true
    local task="$*"

    if [ -z "$name" ] || [ -z "$task" ]; then
        echo -e "${YELLOW}Usage: /agent spawn <name> <task>${NC}"
        return 1
    fi

    if ! load_agent_config "$name"; then
        return 1
    fi

    local log_file="$AGENT_DIR/agent.log"
    local pid_file="$AGENT_DIR/agent.pid"
    local memory_file="$AGENT_DIR/memory.log"
    local history_file="$AGENT_DIR/history.log"

    local cody_bin
    cody_bin=$(resolve_cody_bin)
    if [ ! -x "$cody_bin" ]; then
        echo -e "${RED}‚úó Cody executable not found: $cody_bin${NC}"
        return 1
    fi

    if command -v nohup > /dev/null 2>&1; then
        nohup env \
            CODY_SYSTEM_PROMPT="$AGENT_SYSTEM_PROMPT" \
            WORK_DIR="$AGENT_WORK_DIR" \
            MEMORY_FILE="$memory_file" \
            HISTORY_FILE="$history_file" \
            MODEL_NAME="$AGENT_MODEL_NAME" \
            API_PROVIDER="$AGENT_API_PROVIDER" \
            PROVIDER_NAME="$AGENT_PROVIDER_NAME" \
            GEMMA_ENDPOINT="$GEMMA_ENDPOINT" \
            OLLAMA_ENDPOINT="$OLLAMA_ENDPOINT" \
            OPENROUTER_ENDPOINT="$OPENROUTER_ENDPOINT" \
            OPENROUTER_API_KEY="$OPENROUTER_API_KEY" \
            OPENROUTER_APP_NAME="$OPENROUTER_APP_NAME" \
            OPENROUTER_HTTP_REFERER="$OPENROUTER_HTTP_REFERER" \
            "$cody_bin" <<< "$task" > "$log_file" 2>&1 &
    else
        env \
            CODY_SYSTEM_PROMPT="$AGENT_SYSTEM_PROMPT" \
            WORK_DIR="$AGENT_WORK_DIR" \
            MEMORY_FILE="$memory_file" \
            HISTORY_FILE="$history_file" \
            MODEL_NAME="$AGENT_MODEL_NAME" \
            API_PROVIDER="$AGENT_API_PROVIDER" \
            PROVIDER_NAME="$AGENT_PROVIDER_NAME" \
            GEMMA_ENDPOINT="$GEMMA_ENDPOINT" \
            OLLAMA_ENDPOINT="$OLLAMA_ENDPOINT" \
            OPENROUTER_ENDPOINT="$OPENROUTER_ENDPOINT" \
            OPENROUTER_API_KEY="$OPENROUTER_API_KEY" \
            OPENROUTER_APP_NAME="$OPENROUTER_APP_NAME" \
            OPENROUTER_HTTP_REFERER="$OPENROUTER_HTTP_REFERER" \
            "$cody_bin" <<< "$task" > "$log_file" 2>&1 &
    fi

    local pid=$!
    echo "$pid" > "$pid_file"
    if command -v disown > /dev/null 2>&1; then
        disown "$pid" 2>/dev/null || true
    fi

    echo -e "${GREEN}‚úì Spawned agent '${name}' (pid ${pid})${NC}"
    echo -e "${GRAY}Logs: ${log_file}${NC}"
}

agent_stop() {
    local name="$1"
    local mode="$2"
    if [ -z "$name" ]; then
        echo -e "${YELLOW}Usage: /agent stop <name> [--force]${NC}"
        return 1
    fi

    local agent_dir
    agent_dir=$(agent_dir_for "$name")
    local pid_file="$agent_dir/agent.pid"
    if [ ! -f "$pid_file" ]; then
        echo -e "${RED}‚úó No running agent recorded for: $name${NC}"
        return 1
    fi

    local pid
    pid=$(cat "$pid_file")
    if [ -z "$pid" ] || ! kill -0 "$pid" 2>/dev/null; then
        echo -e "${YELLOW}‚ö†Ô∏è  Agent already stopped: $name${NC}"
        return 0
    fi

    if [ "$mode" = "--force" ]; then
        kill -9 "$pid" 2>/dev/null || true
        echo -e "${GREEN}‚úì Force-stopped agent '${name}' (pid ${pid})${NC}"
        return 0
    fi

    kill "$pid" 2>/dev/null || true
    echo -e "${GREEN}‚úì Stopped agent '${name}' (pid ${pid})${NC}"
}

agent_logs() {
    local name="$1"
    if [ -z "$name" ]; then
        echo -e "${YELLOW}Usage: /agent logs <name>${NC}"
        return 1
    fi

    local agent_dir
    agent_dir=$(agent_dir_for "$name")
    local log_file="$agent_dir/agent.log"
    if [ ! -f "$log_file" ]; then
        echo -e "${YELLOW}No log file found for agent: $name${NC}"
        return 0
    fi

    echo -e "${BLUE}üìú Logs (${name})${NC}"
    tail -n 50 "$log_file"
}

# Session profile helpers
ensure_profiles_file() {
    if [ ! -f "$CODY_PROFILES_FILE" ]; then
        cat <<EOF > "$CODY_PROFILES_FILE"
# Cody session profiles
# Each profile is a named section with key=value pairs.
# Secrets such as OPENROUTER_API_KEY should be stored in .env or environment variables.
EOF
    fi
}

list_profiles() {
    if [ ! -f "$CODY_PROFILES_FILE" ]; then
        echo -e "${YELLOW}No profiles found yet.${NC}"
        return 0
    fi
    local profiles
    profiles=$(awk '/^\[.*\]$/ {gsub(/\[|\]/, "", $0); print $0}' "$CODY_PROFILES_FILE")
    if [ -z "$profiles" ]; then
        echo -e "${YELLOW}No profiles found yet.${NC}"
        return 0
    fi
    echo -e "${BLUE}üìå Profiles:${NC}"
    echo "$profiles" | while IFS= read -r profile; do
        if [ "$profile" = "$PROFILE_NAME" ]; then
            echo -e "  ${GREEN}${profile}${NC} ${GRAY}(active)${NC}"
        else
            echo -e "  ${WHITE}${profile}${NC}"
        fi
    done
}

save_profile() {
    local profile="$1"
    if [ -z "$profile" ]; then
        echo -e "${YELLOW}Usage: /profile save <name>${NC}"
        return 1
    fi

    ensure_profiles_file
    local tmp_file
    tmp_file=$(mktemp)

    awk -v profile="$profile" '
        BEGIN {skip=0}
        $0 ~ "^\\["profile"\\]$" {skip=1; next}
        $0 ~ "^\\[" {skip=0}
        !skip {print}
    ' "$CODY_PROFILES_FILE" > "$tmp_file"

    {
        echo ""
        echo "[$profile]"
        echo "WORK_DIR=$WORK_DIR"
        echo "API_PROVIDER=$API_PROVIDER"
        echo "GEMMA_ENDPOINT=$GEMMA_ENDPOINT"
        echo "OLLAMA_ENDPOINT=$OLLAMA_ENDPOINT"
        echo "OPENROUTER_ENDPOINT=$OPENROUTER_ENDPOINT"
        echo "OPENROUTER_HTTP_REFERER=$OPENROUTER_HTTP_REFERER"
        echo "OPENROUTER_APP_NAME=$OPENROUTER_APP_NAME"
        echo "MODEL_NAME=$MODEL_NAME"
        echo "PROVIDER_NAME=$PROVIDER_NAME"
        echo "MEMORY_FILE=$MEMORY_FILE"
    } >> "$tmp_file"

    mv "$tmp_file" "$CODY_PROFILES_FILE"
    PROFILE_NAME="$profile"
    echo "$PROFILE_NAME" > "$HOME/.cody_profile"
    echo -e "${GREEN}‚úì Saved profile: $PROFILE_NAME${NC}"
}

load_profile() {
    local profile="$1"
    if [ -z "$profile" ]; then
        echo -e "${YELLOW}Usage: /profile use <name>${NC}"
        return 1
    fi
    if [ ! -f "$CODY_PROFILES_FILE" ]; then
        echo -e "${RED}‚úó No profiles file found${NC}"
        return 1
    fi

    local profile_data
    profile_data=$(awk -v profile="$profile" '
        $0 ~ "^\\["profile"\\]$" {in_section=1; next}
        in_section && $0 ~ "^\\[" {exit}
        in_section {print}
    ' "$CODY_PROFILES_FILE")

    if [ -z "$profile_data" ]; then
        echo -e "${RED}‚úó Profile not found: $profile${NC}"
        return 1
    fi

    while IFS='=' read -r key value; do
        key=$(echo "$key" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
        value=$(echo "$value" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
        case "$key" in
            WORK_DIR) WORK_DIR="$value" ;;
            API_PROVIDER) API_PROVIDER="$value" ;;
            GEMMA_ENDPOINT) GEMMA_ENDPOINT="$value" ;;
            OLLAMA_ENDPOINT) OLLAMA_ENDPOINT="$value" ;;
            OPENROUTER_ENDPOINT) OPENROUTER_ENDPOINT="$value" ;;
            OPENROUTER_HTTP_REFERER) OPENROUTER_HTTP_REFERER="$value" ;;
            OPENROUTER_APP_NAME) OPENROUTER_APP_NAME="$value" ;;
            MODEL_NAME) MODEL_NAME="$value" ;;
            PROVIDER_NAME) PROVIDER_NAME="$value" ;;
            MEMORY_FILE) MEMORY_FILE="$value" ;;
        esac
    done <<< "$profile_data"

    PROFILE_NAME="$profile"
    echo "$PROFILE_NAME" > "$HOME/.cody_profile"
    echo -e "${GREEN}‚úì Loaded profile: $PROFILE_NAME${NC}"
    validate_work_dir
}

delete_profile() {
    local profile="$1"
    if [ -z "$profile" ]; then
        echo -e "${YELLOW}Usage: /profile delete <name>${NC}"
        return 1
    fi
    if [ ! -f "$CODY_PROFILES_FILE" ]; then
        echo -e "${RED}‚úó No profiles file found${NC}"
        return 1
    fi
    local tmp_file
    tmp_file=$(mktemp)
    awk -v profile="$profile" '
        BEGIN {skip=0}
        $0 ~ "^\\["profile"\\]$" {skip=1; next}
        $0 ~ "^\\[" {skip=0}
        !skip {print}
    ' "$CODY_PROFILES_FILE" > "$tmp_file"
    mv "$tmp_file" "$CODY_PROFILES_FILE"

    if [ "$PROFILE_NAME" = "$profile" ]; then
        PROFILE_NAME=""
        rm -f "$HOME/.cody_profile"
    fi
    echo -e "${GREEN}‚úì Deleted profile: $profile${NC}"
}

show_profile() {
    local profile="${1:-$PROFILE_NAME}"
    if [ -z "$profile" ]; then
        echo -e "${YELLOW}Usage: /profile show <name>${NC}"
        return 1
    fi
    if [ ! -f "$CODY_PROFILES_FILE" ]; then
        echo -e "${RED}‚úó No profiles file found${NC}"
        return 1
    fi

    local profile_data
    profile_data=$(awk -v profile="$profile" '
        $0 ~ "^\\["profile"\\]$" {in_section=1; next}
        in_section && $0 ~ "^\\[" {exit}
        in_section {print}
    ' "$CODY_PROFILES_FILE")

    if [ -z "$profile_data" ]; then
        echo -e "${RED}‚úó Profile not found: $profile${NC}"
        return 1
    fi

    echo -e "${BLUE}üìå Profile: ${profile}${NC}"
    echo "$profile_data" | while IFS= read -r line; do
        [ -n "$line" ] && echo -e "  ${GRAY}${line}${NC}"
    done
}

load_profile_preference() {
    if [ -f "$HOME/.cody_profile" ]; then
        PROFILE_NAME=$(cat "$HOME/.cody_profile")
        if [ -n "$PROFILE_NAME" ]; then
            load_profile "$PROFILE_NAME"
        fi
    fi
}

# Command discovery suggestions
cody_command_suggestions() {
    local input="$READLINE_LINE"
    local suggestions=()
    local prefix="$input"
    local cmd=""
    local rest=""

    if [[ "$input" == /* ]]; then
        cmd="${input%% *}"
        rest="${input#"$cmd"}"
        rest="${rest# }"
        if [[ " ${FILE_COMMANDS[*]} " == *" $cmd "* ]]; then
            local file_matches=()
            if [ -d "$WORK_DIR" ]; then
                while IFS= read -r match; do
                    [ -f "$WORK_DIR/$match" ] && file_matches+=("$match")
                done < <(cd "$WORK_DIR" && compgen -f -- "$rest")
            fi
            suggestions+=("${file_matches[@]}")
        else
            suggestions+=($(compgen -W "${DEFAULT_COMMANDS[*]}" -- "$prefix"))
        fi
    else
        suggestions+=($(compgen -W "${DEFAULT_COMMANDS[*]}" -- "$prefix"))
    fi

    if [ -f "$HISTORY_FILE" ] && [ -n "$prefix" ]; then
        local history_matches=()
        while IFS= read -r line; do
            if [[ "$line" == "$prefix"* ]]; then
                history_matches+=("$line")
            fi
        done < "$HISTORY_FILE"
        suggestions+=("${history_matches[@]}")
    fi

    if [ ${#suggestions[@]} -eq 0 ]; then
        echo
        echo -e "${GRAY}No suggestions yet. Try /help for guidance.${NC}"
        return
    fi

    declare -A seen
    local unique=()
    for suggestion in "${suggestions[@]}"; do
        if [ -n "$suggestion" ] && [ -z "${seen[$suggestion]}" ]; then
            unique+=("$suggestion")
            seen[$suggestion]=1
        fi
    done

    echo
    echo -e "${GRAY}Suggestions:${NC} ${unique[*]}"
}

# Interactive onboarding wizard
run_onboarding_wizard() {
    local env_path="$WORK_DIR/.env"
    if [ -f "$env_path" ] || [ -f "$HOME/.cody_env" ] || [ -f "$ONBOARDING_FLAG" ]; then
        return 0
    fi

    echo -e "${BLUE}üß≠ Welcome! Let's set up Cody.${NC}"
    echo -e "${GRAY}We'll guide you through endpoint, model, and optional profile setup.${NC}"
    local choice
    read -r -p "$(echo -e "${GREEN}Run onboarding wizard now? (Y/n): ${NC}")" choice
    if [[ "$choice" =~ ^[Nn]$ ]]; then
        echo -e "${YELLOW}Skipping onboarding. You can run /wizard later.${NC}"
        touch "$ONBOARDING_FLAG"
        return 0
    fi

    local provider_choice
    echo -e "${BLUE}Select your API provider:${NC}"
    echo -e "  ${YELLOW}1.${NC} LM Studio (default)"
    echo -e "  ${YELLOW}2.${NC} Ollama"
    echo -e "  ${YELLOW}3.${NC} OpenRouter"
    read -r -p "$(echo -e "${GREEN}Choose 1-3 [1]: ${NC}")" provider_choice

    case "$provider_choice" in
        2)
            API_PROVIDER="ollama"
            GEMMA_ENDPOINT="$OLLAMA_ENDPOINT"
            ;;
        3)
            API_PROVIDER="openrouter"
            GEMMA_ENDPOINT="$OPENROUTER_ENDPOINT"
            ;;
        *)
            API_PROVIDER="lmstudio"
            GEMMA_ENDPOINT="$GEMMA_ENDPOINT"
            ;;
    esac

    local endpoint_input
    read -r -p "$(echo -e "${GREEN}Endpoint URL [$GEMMA_ENDPOINT]: ${NC}")" endpoint_input
    if [ -n "$endpoint_input" ]; then
        GEMMA_ENDPOINT="$endpoint_input"
    fi

    if [ "$API_PROVIDER" = "openrouter" ]; then
        echo -e "${YELLOW}Note: Set OPENROUTER_API_KEY in .env or your shell for API access.${NC}"
        read -r -p "$(echo -e "${GREEN}Model name (e.g. mistralai/codestral-22b-v0.1) [${MODEL_NAME}]: ${NC}")" model_choice
        if [ -n "$model_choice" ]; then
            MODEL_NAME="$model_choice"
        fi
    else
        if test_endpoint "$GEMMA_ENDPOINT" "$API_PROVIDER"; then
            fetch_available_models
            if [ ${#AVAILABLE_MODELS[@]} -gt 0 ]; then
                echo -e "${BLUE}Available models:${NC}"
                local i=1
                for model in "${AVAILABLE_MODELS[@]}"; do
                    echo -e "  ${YELLOW}${i}.${NC} $model"
                    ((i++))
                done
                read -r -p "$(echo -e "${GREEN}Select model (1-${#AVAILABLE_MODELS[@]}) [current]: ${NC}")" model_choice
                if [[ "$model_choice" =~ ^[0-9]+$ ]] && [ "$model_choice" -ge 1 ] && [ "$model_choice" -le ${#AVAILABLE_MODELS[@]} ]; then
                    MODEL_NAME="${AVAILABLE_MODELS[$((model_choice-1))]}"
                fi
            fi
        else
            echo -e "${YELLOW}Endpoint validation failed. You can update it later in .env.${NC}"
        fi
    fi

    local create_env_choice
    read -r -p "$(echo -e "${GREEN}Create a project .env file? (Y/n): ${NC}")" create_env_choice
    if [[ ! "$create_env_choice" =~ ^[Nn]$ ]]; then
        cat <<EOF > "$env_path"
# Cody configuration for ${WORK_DIR}
API_PROVIDER="${API_PROVIDER}"
MODEL_NAME="${MODEL_NAME}"
GEMMA_ENDPOINT="${GEMMA_ENDPOINT}"
OLLAMA_ENDPOINT="${OLLAMA_ENDPOINT}"
OPENROUTER_ENDPOINT="${OPENROUTER_ENDPOINT}"
OPENROUTER_APP_NAME="${OPENROUTER_APP_NAME}"
OPENROUTER_HTTP_REFERER="${OPENROUTER_HTTP_REFERER}"
EOF
        echo -e "${GREEN}‚úì Created .env at ${env_path}${NC}"
    fi

    local profile_choice
    read -r -p "$(echo -e "${GREEN}Save a session profile for this setup? (Y/n): ${NC}")" profile_choice
    if [[ ! "$profile_choice" =~ ^[Nn]$ ]]; then
        local default_profile
        default_profile=$(basename "$WORK_DIR")
        local profile_name
        read -r -p "$(echo -e "${GREEN}Profile name [${default_profile}]: ${NC}")" profile_name
        profile_name="${profile_name:-$default_profile}"
        MEMORY_FILE="${DEFAULT_PROFILE_MEMORY_DIR}/.cody_memory_${profile_name}"
        save_profile "$profile_name"
    fi

    touch "$ONBOARDING_FLAG"
    echo -e "${GREEN}‚úì Onboarding complete. You're ready to go.${NC}"
}

# Verify work directory exists
validate_work_dir() {
    if [ ! -d "$WORK_DIR" ]; then
        echo -e "${YELLOW}‚ö†Ô∏è WORK_DIR not found: $WORK_DIR${NC}"
        WORK_DIR="$(pwd)"
        echo -e "${GREEN}‚úì Using current directory: $WORK_DIR${NC}"
    fi
}

# Ensure dependencies are available
ensure_dependencies() {
    local missing=()
    command -v curl > /dev/null || missing+=("curl")
    command -v jq > /dev/null || missing+=("jq")

    if [ ${#missing[@]} -gt 0 ]; then
        echo -e "${RED}Missing dependencies: ${missing[*]}${NC}"
        return 1
    fi
}

# Build request headers for API calls
build_request_headers() {
    local -n headers_ref=$1
    headers_ref=("-H" "Content-Type: application/json")

    if [ "$API_PROVIDER" = "openrouter" ]; then
        if [ -z "$OPENROUTER_API_KEY" ]; then
            echo -e "${RED}‚úó OPENROUTER_API_KEY not set${NC}" >&2
            return 1
        fi
        headers_ref+=("-H" "Authorization: Bearer $OPENROUTER_API_KEY")
        if [ -n "$OPENROUTER_HTTP_REFERER" ]; then
            headers_ref+=("-H" "HTTP-Referer: $OPENROUTER_HTTP_REFERER")
        fi
        if [ -n "$OPENROUTER_APP_NAME" ]; then
            headers_ref+=("-H" "X-Title: $OPENROUTER_APP_NAME")
        fi
    fi
}

# Test endpoint connectivity
test_endpoint() {
    local endpoint="$1"
    local provider="${2:-$API_PROVIDER}"
    local http_code
    local headers=()

    if [ "$provider" = "openrouter" ]; then
        if ! build_request_headers headers; then
            return 1
        fi
    fi

    http_code=$(curl -s -o /dev/null -w "%{http_code}" \
        "${headers[@]}" \
        --connect-timeout "$CONNECT_TIMEOUT" \
        --max-time "$API_TIMEOUT" \
        "$endpoint/v1/models" 2>/dev/null)

    if [[ "$http_code" =~ ^2 ]]; then
        return 0
    fi

    if [ -z "$http_code" ] || [ "$http_code" = "000" ]; then
        echo -e "${RED}‚úó Cannot connect to $endpoint${NC}"
    else
        echo -e "${RED}‚úó Endpoint returned HTTP $http_code from $endpoint${NC}"
    fi
    return 1
}

# Manage backup files - keep only MAX_BACKUPS
manage_backups() {
    local backup_pattern="$0.backup.*"
    local backup_files=($(ls -t $backup_pattern 2>/dev/null))
    
    if [ ${#backup_files[@]} -gt $MAX_BACKUPS ]; then
        echo -e "${BLUE}Managing backups (keeping $MAX_BACKUPS most recent)${NC}"
        
        # Remove oldest backups
        for ((i=MAX_BACKUPS; i<${#backup_files[@]}; i++)); do
            echo -e "${GRAY}Removing old backup: ${backup_files[i]##*/}${NC}"
            rm -f "${backup_files[i]}"
        done
    fi
}

# Load saved model preference
load_model_preference() {
    if [ -f "$HOME/.cody_model" ]; then
        MODEL_NAME=$(cat "$HOME/.cody_model")
    fi
}

# Load saved provider preference
load_provider_preference() {
    if [ -f "$HOME/.cody_provider" ]; then
        PROVIDER_NAME=$(cat "$HOME/.cody_provider")
    fi
}

# Fetch available models
fetch_available_models() {
    AVAILABLE_MODELS=()
    local headers=()
    if ! build_request_headers headers; then
        return 1
    fi

    local resp=$(curl -s \
        "${headers[@]}" \
        --connect-timeout "$CONNECT_TIMEOUT" \
        --max-time "$API_TIMEOUT" \
        "$GEMMA_ENDPOINT/v1/models" 2>/dev/null)
    if [ -n "$resp" ]; then
        if [ "$API_PROVIDER" = "openrouter" ]; then
            mapfile -t AVAILABLE_MODELS < <(echo "$resp" | jq -r '.data[].id // empty' | sort -u)
        else
            mapfile -t AVAILABLE_MODELS < <(echo "$resp" | jq -r '..|.id? // empty' | sort -u)
        fi
    fi
}

# Detect Ollama
detect_ollama() {
    curl -s \
        --connect-timeout "$CONNECT_TIMEOUT" \
        --max-time "$API_TIMEOUT" \
        "$OLLAMA_ENDPOINT/v1/models" >/dev/null 2>&1
}

# Select endpoint
select_endpoint() {
    local endpoints=("$GEMMA_ENDPOINT")
    local names=("LM Studio ($GEMMA_ENDPOINT)")
    local providers=("lmstudio")

    if detect_ollama; then
        endpoints+=("$OLLAMA_ENDPOINT")
        names+=("Ollama ($OLLAMA_ENDPOINT)")
        providers+=("ollama")
    fi

    if [ -n "$OPENROUTER_API_KEY" ]; then
        endpoints+=("$OPENROUTER_ENDPOINT")
        names+=("OpenRouter ($OPENROUTER_ENDPOINT)")
        providers+=("openrouter")
    fi

    # Check if we're in non-interactive mode
    if [ ! -t 0 ]; then
        case "$API_PROVIDER" in
            openrouter)
                if [ -z "$OPENROUTER_API_KEY" ]; then
                    echo -e "${RED}‚úó OPENROUTER_API_KEY not set${NC}"
                    return 1
                fi
                GEMMA_ENDPOINT="$OPENROUTER_ENDPOINT"
                ;;
            ollama)
                GEMMA_ENDPOINT="$OLLAMA_ENDPOINT"
                ;;
            *)
                API_PROVIDER="lmstudio"
                ;;
        esac
        echo -e "${GREEN}‚úì Using endpoint: $GEMMA_ENDPOINT${NC}"
        return
    fi

    if [ ${#endpoints[@]} -gt 1 ]; then
        echo -e "${BLUE}Available servers:${NC}"
        local i=1
        for name in "${names[@]}"; do
            echo -e "  ${YELLOW}${i}.${NC} $name"
            ((i++))
        done
        echo

        local choice
        read -e -p "$(echo -e "${GREEN}Select server (1-${#endpoints[@]}) or Enter for default [1]: ${NC}")" choice
        if [[ $choice =~ ^[0-9]+$ ]] && [ "$choice" -ge 1 ] && [ "$choice" -le ${#endpoints[@]} ]; then
            GEMMA_ENDPOINT="${endpoints[$((choice-1))]}"
            API_PROVIDER="${providers[$((choice-1))]}"
        fi
    fi

    echo -e "${GREEN}‚úì Using endpoint: $GEMMA_ENDPOINT${NC}"
}

# Setup readline
setup_readline() {
    set -o emacs
    trap 'print_header' WINCH

    # Bind ESC to a custom handler that sets a flag
    bind '"\e": " \C-u__CODY_ESC__\n"'
    bind -x '"\t": cody_command_suggestions'

    if [ -f "$HISTORY_FILE" ]; then
        while IFS= read -r line; do
            history -s "$line"
        done < "$HISTORY_FILE"
    fi

    bind 'set completion-ignore-case on'
    bind 'set show-all-if-ambiguous on'
    bind '"\e[A": history-search-backward'
    bind '"\e[B": history-search-forward'
    bind '"\C-a": beginning-of-line'
    bind '"\C-e": end-of-line'
    bind '"\C-k": kill-line'
    bind '"\C-u": unix-line-discard'
    bind '"\C-w": unix-word-rubout'
}

# Enhanced input
read_input_enhanced() {
    local input
    IFS= read -e -r input

    # ESC handler: if input is our special string, treat as cancel
    if [[ "$input" == "__CODY_ESC__" ]]; then
        echo "__CODY_ESC__"
        return 130
    fi

    if [[ -n "$input" && "$input" != " "* ]]; then
        history -s "$input"
        echo "$input" >> "$HISTORY_FILE"

        if [ -f "$HISTORY_FILE" ] && (( $(wc -l < "$HISTORY_FILE") > 1000 )); then
            tail -n 1000 "$HISTORY_FILE" > "$HISTORY_FILE.tmp" && mv "$HISTORY_FILE.tmp" "$HISTORY_FILE"
        fi
    fi

    echo "$input"
}

# Model selection
select_model() {
    fetch_available_models

    if [ ${#AVAILABLE_MODELS[@]} -eq 0 ]; then
        echo -e "${RED}No models available${NC}"
        return 1
    fi

    echo -e "${BLUE}ü§ñ Available Models:${NC}"
    local i=1
    for model in "${AVAILABLE_MODELS[@]}"; do
        if [ "$model" = "$MODEL_NAME" ]; then
            echo -e "  ${YELLOW}${i}.${NC} ${GREEN}${model} (current)${NC}"
        else
            echo -e "  ${YELLOW}${i}.${NC} ${model}"
        fi
        ((i++))
    done
    echo

    local choice
    read -e -p "$(echo -e "${GREEN}Select model (1-${#AVAILABLE_MODELS[@]}) or Enter for current: ${NC}")" choice

    if [[ $choice =~ ^[0-9]+$ ]] && [ "$choice" -ge 1 ] && [ "$choice" -le ${#AVAILABLE_MODELS[@]} ]; then
        MODEL_NAME="${AVAILABLE_MODELS[$((choice-1))]}"
        echo -e "${GREEN}‚úì Switched to: $MODEL_NAME${NC}"
        echo "$MODEL_NAME" > "$HOME/.cody_model"
    fi
}

# Provider selection (OpenRouter)
select_provider() {
    if [ "$API_PROVIDER" != "openrouter" ]; then
        echo -e "${YELLOW}Provider selection is only available with OpenRouter${NC}"
        return 1
    fi

    local current_provider="${PROVIDER_NAME:-auto}"
    local choice
    read -e -p "$(echo -e "${GREEN}Enter provider name or press Enter for auto [${current_provider}]: ${NC}")" choice

    if [ -z "$choice" ]; then
        PROVIDER_NAME=""
        rm -f "$HOME/.cody_provider"
        echo -e "${GREEN}‚úì Provider set to auto${NC}"
    else
        PROVIDER_NAME="$choice"
        echo "$PROVIDER_NAME" > "$HOME/.cody_provider"
        echo -e "${GREEN}‚úì Provider set to: $PROVIDER_NAME${NC}"
    fi
}

# Header with proper word wrapping
print_header() {
    clear
    local term_width=$(tput cols 2>/dev/null || echo 80)
    
    local top_border="‚ï≠"
    for ((i=1; i<term_width-1; i++)); do
        top_border+="‚îÄ"
    done
    top_border+="‚ïÆ"
    
    local bottom_border="‚ï∞"
    for ((i=1; i<term_width-1; i++)); do
        bottom_border+="‚îÄ"
    done
    bottom_border+="‚ïØ"
    
    local title="ü§ñ Self-Modifying Cody"
    local subtitle="AI Development Assistant by Mark Hubrich"
    local title_padding=$(( (term_width - ${#title} - 2) / 2 ))
    local subtitle_padding=$(( (term_width - ${#subtitle} - 2) / 2 ))
    
    echo -e "${CYAN}$top_border${NC}"
    
    printf "${CYAN}‚îÇ${NC}"
    printf "%*s" $title_padding ""
    printf "${WHITE}%s${NC}" "$title"
    printf "%*s" $((term_width - title_padding - ${#title} - 2)) ""
    printf "${CYAN}‚îÇ${NC}\n"
    
    printf "${CYAN}‚îÇ${NC}"
    printf "%*s" $subtitle_padding ""
    printf "${GRAY}%s${NC}" "$subtitle"
    printf "%*s" $((term_width - subtitle_padding - ${#subtitle} - 2)) ""
    printf "${CYAN}‚îÇ${NC}\n"
    
    echo -e "${CYAN}$bottom_border${NC}"
    echo
    echo -e "${GRAY}Commands:${NC}"
    echo -e "  ${BLUE}/create${NC} <filename> <description>   ${GRAY}Create new file${NC}"
    echo -e "  ${BLUE}/edit${NC} <filename>                  ${GRAY}Edit file${NC}"
    echo -e "  ${BLUE}/run${NC} <filename>                   ${GRAY}Execute file${NC}"
    echo -e "  ${BLUE}/explain${NC} <filename>               ${GRAY}Explain code${NC}"
    echo -e "  ${BLUE}/fix${NC} <filename> <issue>           ${GRAY}Fix code${NC}"
    echo -e "  ${BLUE}/files${NC}                            ${GRAY}List files${NC}"
    echo -e "  ${BLUE}/exec${NC} <command>                   ${GRAY}Execute shell command${NC}"
    echo -e "  ${BLUE}/pip${NC} <args> | ${BLUE}/npm${NC} <args> | ${BLUE}/pnpm${NC} <args> | ${BLUE}/yarn${NC} <args>"
    echo -e "  ${BLUE}/selfmod${NC} <description>            ${GRAY}Modify myself${NC}"
    echo -e "  ${BLUE}/reload${NC}                           ${GRAY}Reload system prompt${NC}"
    echo -e "  ${BLUE}/status${NC}                           ${GRAY}Show endpoint status${NC}"
    echo -e "  ${BLUE}/doctor${NC}                           ${GRAY}Run diagnostics${NC}"
    echo -e "  ${BLUE}/profile${NC}                          ${GRAY}Manage session profiles${NC}"
    echo -e "  ${BLUE}/agent${NC}                            ${GRAY}Manage and spawn agents${NC}"
    echo -e "  ${BLUE}/wizard${NC}                           ${GRAY}Run onboarding wizard${NC}"
    echo -e "  ${BLUE}/model${NC} | ${BLUE}/provider${NC} | ${BLUE}/clear${NC} | ${BLUE}/help${NC} | ${BLUE}/exit${NC}"
    echo -e "${GRAY}Tip: Press Tab for contextual suggestions. Use /help <query> to search.${NC}"
    echo
    echo -e "${CYAN}Model:${NC} ${MODEL_NAME}"
    if [ "$API_PROVIDER" = "openrouter" ]; then
        local provider_label="${PROVIDER_NAME:-auto}"
        echo -e "${CYAN}Provider:${NC} ${provider_label}"
    fi
    if [ -n "$PROFILE_NAME" ]; then
        echo -e "${CYAN}Profile:${NC} ${PROFILE_NAME}"
    fi
    echo -e "${CYAN}Directory:${NC} ${WORK_DIR}"
    
    # System prompt with proper word wrapping
    echo -e "${CYAN}System Prompt:${NC}"
    if [ -n "$SYSTEM_PROMPT" ]; then
        # Extract first 2 lines of system prompt for display
        local prompt_preview=$(echo "$SYSTEM_PROMPT" | head -n 2 | fold -w $((term_width - 4)) -s)
        echo "$prompt_preview" | while IFS= read -r line; do
            echo -e "${GRAY}  $line${NC}"
        done
        
        # Show if there's more content
        local line_count=$(echo "$SYSTEM_PROMPT" | wc -l)
        if [ "$line_count" -gt 2 ]; then
            echo -e "${GRAY}  ... (${line_count} total lines)${NC}"
        fi
    else
        echo -e "${GRAY}  No system prompt loaded${NC}"
    fi
    
    echo
    echo -e "${CYAN}Powers:${NC} ${GRAY}Self-Modification ${GEAR} Command Execution ${LIGHTNING} File Operations${NC}"
    
    local separator=""
    for ((i=0; i<term_width; i++)); do
        separator+="‚îÄ"
    done
    echo -e "${GRAY}$separator${NC}"
    echo
}

# Help display (grouped + searchable)
print_help() {
    local query="$1"
    local -a sections=(
        "Creation & Editing"
        "Execution & Tools"
        "AI Assistance"
        "Agents"
        "Configuration & Profiles"
        "Navigation"
    )

    local -a items_creation=(
        "/create <filename> <description> - Create a new file"
        "/edit <filename> - Edit a file"
        "/files [--no-dotfiles|--sources] - List files"
    )
    local -a items_execution=(
        "/run <filename> - Run a file"
        "/exec <command> - Execute shell command"
        "/pip <args> - Run pip"
        "/npm <args> - Run npm"
        "/pnpm <args> - Run pnpm"
        "/yarn <args> - Run yarn"
    )
    local -a items_ai=(
        "/explain <filename> - Explain code"
        "/fix <filename> <issue> - Fix code"
        "/selfmod <description> - Modify Cody"
    )
    local -a items_agents=(
        "/agent list - List agents"
        "/agent create <name> <system prompt> - Create an agent"
        "/agent show <name> - Show agent configuration"
        "/agent spawn <name> <task> - Spawn agent in a subprocess"
        "/agent stop <name> [--force] - Stop a running agent"
        "/agent logs <name> - Tail agent logs"
        "/agent delete <name> - Delete an agent"
    )
    local -a items_config=(
        "/model - Select model"
        "/provider - Select OpenRouter provider"
        "/status - Show endpoint status"
        "/doctor - Run diagnostics"
        "/reload - Reload system prompt"
        "/profile list|use|save|delete|show - Manage session profiles"
        "/wizard - Run onboarding wizard"
    )
    local -a items_nav=(
        "/help [query] - Show help or search commands"
        "/clear - Clear memory"
        "/exit - Exit Cody"
    )

    echo -e "${BLUE}üìò Help${NC}"
    if [ -n "$query" ]; then
        echo -e "${GRAY}Searching for: ${query}${NC}"
        printf "%s\n" \
            "${items_creation[@]}" \
            "${items_execution[@]}" \
            "${items_ai[@]}" \
            "${items_agents[@]}" \
            "${items_config[@]}" \
            "${items_nav[@]}" | grep -i "$query" | while IFS= read -r line; do
                echo -e "  ${WHITE}${line}${NC}"
            done
        return 0
    fi

    echo -e "${CYAN}${sections[0]}${NC}"
    for line in "${items_creation[@]}"; do echo -e "  ${WHITE}${line}${NC}"; done
    echo -e "${CYAN}${sections[1]}${NC}"
    for line in "${items_execution[@]}"; do echo -e "  ${WHITE}${line}${NC}"; done
    echo -e "${CYAN}${sections[2]}${NC}"
    for line in "${items_ai[@]}"; do echo -e "  ${WHITE}${line}${NC}"; done
    echo -e "${CYAN}${sections[3]}${NC}"
    for line in "${items_agents[@]}"; do echo -e "  ${WHITE}${line}${NC}"; done
    echo -e "${CYAN}${sections[4]}${NC}"
    for line in "${items_config[@]}"; do echo -e "  ${WHITE}${line}${NC}"; done
    echo -e "${CYAN}${sections[5]}${NC}"
    for line in "${items_nav[@]}"; do echo -e "  ${WHITE}${line}${NC}"; done
}

# Typing animation
show_typing() {
    local message="$1"
    echo -e -n "${BLUE}${message}${NC}"
    for i in {1..3}; do
        sleep 0.2
        echo -n "."
    done
    echo
}

# Project context
get_project_context() {
    local context="Project: $WORK_DIR
"
    local file_count=0
    cd "$WORK_DIR" || return
    shopt -s nullglob
    for file in *; do
        if [ -f "$file" ] && [[ ! "$file" =~ ^cody ]] && [ ${#file} -lt 50 ]; then
            local lines=$(wc -l < "$file" 2>/dev/null || echo "0")
            if [ "$lines" -lt 200 ]; then
                context="$context- $file ($lines lines)
"
                ((file_count++))
            fi
        fi
    done
    shopt -u nullglob
    context="$context
Files: $file_count
"
    echo -e "$context"
}

# AI API call with system prompt
call_gemma() {
    local prompt="$1"
    local custom_system_prompt="${2:-$SYSTEM_PROMPT}"
    local temperature="${3:-0.7}"
    
    local context=$(get_project_context)
    local full_prompt="$context

User: $prompt"
    
    local escaped_prompt=$(echo "$full_prompt" | jq -Rs .)
    local escaped_system=$(echo "$custom_system_prompt" | jq -Rs .)
    
    local messages="[{\"role\": \"system\", \"content\": $escaped_system}, {\"role\": \"user\", \"content\": $escaped_prompt}]"
    
    local headers=()
    if ! build_request_headers headers; then
        return 1
    fi

    local provider_payload=""
    if [ "$API_PROVIDER" = "openrouter" ] && [ -n "$PROVIDER_NAME" ]; then
        provider_payload=", \"provider\": {\"order\": [\"$PROVIDER_NAME\"], \"allow_fallbacks\": true}"
    fi

    local response
    response=$(curl -s -w "\n%{http_code}" -X POST "$GEMMA_ENDPOINT/v1/chat/completions" \
        "${headers[@]}" \
        --connect-timeout "$CONNECT_TIMEOUT" \
        --max-time "$API_TIMEOUT" \
        -d "{
            \"model\": \"$MODEL_NAME\",
            \"messages\": $messages,
            \"temperature\": $temperature,
            \"max_tokens\": 4000${provider_payload}
        }" 2>/dev/null)

    if [ -n "$response" ]; then
        local http_code=$(echo "$response" | tail -n 1)
        local body=$(echo "$response" | sed '$d')

        if [[ ! "$http_code" =~ ^2 ]]; then
            if [ -z "$http_code" ] || [ "$http_code" = "000" ]; then
                echo -e "${RED}API Error: Connection failed${NC}" >&2
            else
                echo -e "${RED}API Error: HTTP $http_code${NC}" >&2
            fi
            return 1
        fi

        local error=$(echo "$body" | jq -r '.error.message // empty' 2>/dev/null)
        if [ -n "$error" ]; then
            echo -e "${RED}API Error: $error${NC}" >&2
            return 1
        fi
        
        echo "$body" | jq -r '.choices[0].message.content // empty' 2>/dev/null
    else
        echo -e "${RED}API Error: Empty response${NC}" >&2
        return 1
    fi
}

# Extract code blocks (extract all code blocks, not just the first)
extract_code() {
    local response="$1"
    if echo "$response" | grep -q '```'; then
        # Extract all code blocks between triple backticks
        echo "$response" | awk '/```/{f=!f; next} f'
    else
        echo "$response"
    fi
}

# Format output
format_output() {
    local text="$1"
    local prefix="${2:-}"
    echo "$text" | fold -w 80 -s | sed "s/^/$prefix/"
}

# Save to memory
save_to_memory() {
    local user_input="$1"
    local response="$2"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    echo "[$timestamp] User: $user_input" >> "$MEMORY_FILE"
    echo "[$timestamp] Cody: $response" >> "$MEMORY_FILE"
    echo "---" >> "$MEMORY_FILE"
    
    if [ -f "$MEMORY_FILE" ] && (( $(wc -l < "$MEMORY_FILE") > 400 )); then
        tail -n 400 "$MEMORY_FILE" > "$MEMORY_FILE.tmp" && mv "$MEMORY_FILE.tmp" "$MEMORY_FILE"
    fi
}

# COMMAND EXECUTION ENGINE
execute_command() {
    local command="$1"
    local auto_confirm="${2:-false}"

    echo -e "${BLUE}${LIGHTNING} Executing: ${WHITE}$command${NC}"

    # Safety check (expanded)
    if [[ "$command" =~ (^|[[:space:]])(rm[[:space:]]+-rf|rm[[:space:]]+-fr|sudo|chmod[[:space:]]+777|>[\ \t]*/dev|dd[[:space:]]|mkfs|:(){:|:&};:|shutdown|reboot|poweroff|init[[:space:]]+0|halt|chown[[:space:]]+root|curl[[:space:]]+http|wget[[:space:]]+http|scp[[:space:]]|nc[[:space:]]|netcat[[:space:]]|:(){:|:&};:|kill[[:space:]]+-9[[:space:]]+1)($|[[:space:]]) ]]; then
        echo -e "${RED}‚ö†Ô∏è  Dangerous command blocked${NC}"
        return 1
    fi
    
    # Confirm
    if [[ "$auto_confirm" != "true" ]]; then
        echo -e -n "${YELLOW}Execute? (y/N): ${NC}"
        local confirm
        read -r confirm
        if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
            echo -e "${GRAY}Cancelled${NC}"
            return 1
        fi
    fi
    
    echo -e "${GRAY}‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ${NC}"
    (cd "$WORK_DIR" && eval "$command")
    local exit_code=$?
    echo -e "${GRAY}‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ${NC}"
    
    if [ $exit_code -eq 0 ]; then
        echo -e "${GREEN}‚úì Success${NC}"
    else
        echo -e "${RED}‚úó Failed (exit code: $exit_code)${NC}"
    fi
    
    return $exit_code
}

# PACKAGE MANAGER HELPERS
run_pip_command() {
    local args="$1"
    local pip_cmd=""

    if command -v python3 > /dev/null; then
        pip_cmd="python3 -m pip"
    elif command -v pip3 > /dev/null; then
        pip_cmd="pip3"
    elif command -v pip > /dev/null; then
        pip_cmd="pip"
    else
        echo -e "${RED}‚úó pip not available${NC}"
        return 1
    fi

    if [ -z "$args" ]; then
        echo -e "${YELLOW}Usage: /pip <args>${NC}"
        return 1
    fi

    execute_command "$pip_cmd $args"
}

run_npm_command() {
    local args="$1"
    if ! command -v npm > /dev/null; then
        echo -e "${RED}‚úó npm not available${NC}"
        return 1
    fi

    if [ -z "$args" ]; then
        echo -e "${YELLOW}Usage: /npm <args>${NC}"
        return 1
    fi

    execute_command "npm $args"
}

run_pnpm_command() {
    local args="$1"
    if ! command -v pnpm > /dev/null; then
        echo -e "${RED}‚úó pnpm not available${NC}"
        return 1
    fi

    if [ -z "$args" ]; then
        echo -e "${YELLOW}Usage: /pnpm <args>${NC}"
        return 1
    fi

    execute_command "pnpm $args"
}

run_yarn_command() {
    local args="$1"
    if ! command -v yarn > /dev/null; then
        echo -e "${RED}‚úó yarn not available${NC}"
        return 1
    fi

    if [ -z "$args" ]; then
        echo -e "${YELLOW}Usage: /yarn <args>${NC}"
        return 1
    fi

    execute_command "yarn $args"
}

# SELF-MODIFICATION ENGINE
modify_self() {
    local description="$1"
    
    echo -e "${BLUE}${GEAR} Self-modification: $description${NC}"
    
    local script_path="$0"
    local backup_path="${script_path}.backup.$(date +%Y%m%d_%H%M%S)"
    
    cp "$script_path" "$backup_path"
    echo -e "${GREEN}‚úì Backup: ${backup_path##*/}${NC}"
    
    # Manage backups after creating new one
    manage_backups
    
    show_typing "Analyzing self-modification"
    
    local response=$(call_gemma "I need to modify my own code: $description")
    
    if [ -n "$response" ]; then
        echo -e "${BLUE}${ROBOT} Modification Plan:${NC}"
        echo
        format_output "$response" "  "
        echo
        
        # Check if response contains actual implementation
        if echo "$response" | grep -q "mv\|cp\|mkdir\|chmod\|echo.*>"; then
            echo -e "${GREEN}${TARGET} Implementation detected - executing...${NC}"
            
            # Extract and execute commands from response
            local commands=$(echo "$response" | grep -E "^(mv|cp|mkdir|chmod|echo.*>)" | head -5)
            if [ -n "$commands" ]; then
                echo "$commands" | while read -r cmd; do
                    execute_command "$cmd" "true"
                done
            fi
        fi
        
        local code_block=$(extract_code "$response")
        if [ -n "$code_block" ]; then
            echo -e "${YELLOW}‚ö†Ô∏è  Code changes detected. Review and apply manually.${NC}"
            echo -e "${GRAY}Backup: ${backup_path##*/}${NC}"
        fi
        
        save_to_memory "self-modify: $description" "$response"
    else
        echo -e "${RED}‚úó Self-modification failed${NC}"
        rm "$backup_path"
    fi
}

# ACTION PARSER
is_action_request() {
    local input="$1"
    
    [[ "$input" =~ ^(rename|move|mv|create|make|delete|remove|copy|cp|chmod|mkdir|run|execute|test|check|verify|try|git|pip|pip3|python[[:space:]]+-m[[:space:]]+pip|npm|pnpm|yarn|add.*myself|modify.*myself|improve.*myself|apply.*upgrade|implement.*plan) ]]
}

# ACTION EXECUTOR
execute_action() {
    local input="$1"
    local command=""
    
    case "$input" in
        *"rename"*" to "*|*"move"*" to "*)
            local from=$(echo "$input" | sed 's/.*\(rename\|move\) \([^ ]*\) to.*/\2/')
            local to=$(echo "$input" | sed 's/.* to \([^ ]*\).*/\1/')
            command="mv \"$from\" \"$to\""
            ;;
        *"delete"*|*"remove"*)
            local file=$(echo "$input" | sed 's/.*\(delete\|remove\) \([^ ]*\).*/\2/')
            command="rm \"$file\""
            ;;
        *"copy"*" to "*)
            local from=$(echo "$input" | sed 's/.*copy \([^ ]*\) to.*/\1/')
            local to=$(echo "$input" | sed 's/.* to \([^ ]*\).*/\1/')
            command="cp \"$from\" \"$to\""
            ;;
        *"make executable"*|*"chmod"*)
            local file=$(echo "$input" | sed 's/.*\(make executable\|chmod\) \([^ ]*\).*/\2/')
            command="chmod +x \"$file\""
            ;;
        *"mkdir"*|*"create directory"*)
            local dir=$(echo "$input" | sed 's/.*\(mkdir\|create directory\) \([^ ]*\).*/\2/')
            command="mkdir -p \"$dir\""
            ;;
        *"create"*)
            # Handle complex create commands by delegating to AI
            echo -e "${BLUE}${TARGET} Complex create action: $input${NC}"
            show_typing "Planning creation"
            local response=$(call_gemma "Break down this request into specific commands: $input")
            if [ -n "$response" ]; then
                echo -e "${BLUE}${ROBOT} Plan:${NC}"
                echo
                format_output "$response" "  "
                echo
                # Look for specific commands in the response
                if echo "$response" | grep -q "mkdir\|touch\|echo.*>"; then
                    echo -e "${GREEN}${TARGET} Extracting commands...${NC}"
                    # Extract and execute simple commands - look for lines starting with commands
                    local commands=$(echo "$response" | grep -E "^[[:space:]]*(mkdir|touch|echo.*>)" | head -5)
                    if [ -n "$commands" ]; then
                        echo "$commands" | while read -r cmd; do
                            if [ -n "$cmd" ]; then
                                execute_command "$cmd"
                            fi
                        done
                    fi
                fi
            fi
            return 0
            ;;
        *"myself"*|*"yourself"*|*"upgrade"*|*"implement"*)
            modify_self "$input"
            return 0
            ;;
        pip\ *)
            run_pip_command "${input#pip }"
            return 0
            ;;
        pip3\ *)
            run_pip_command "${input#pip3 }"
            return 0
            ;;
        python\ -m\ pip\ *)
            local pip_args="${input#python -m pip }"
            run_pip_command "$pip_args"
            return 0
            ;;
        npm\ *)
            run_npm_command "${input#npm }"
            return 0
            ;;
        pnpm\ *)
            run_pnpm_command "${input#pnpm }"
            return 0
            ;;
        yarn\ *)
            run_yarn_command "${input#yarn }"
            return 0
            ;;
        *"git "*)
            command="$input"
            ;;
        *"test"*|*"check"*|*"verify"*|*"try"*)
            # Extract filename from test/check commands
            local file=$(echo "$input" | sed -n 's/.*\(test\|check\|verify\|try\)[[:space:]]\+\([^[:space:]]\+\).*/\2/p')
            if [ -n "$file" ]; then
                echo -e "${BLUE}${TARGET} Testing: $file${NC}"
                handle_run "$file"
                return 0
            else
                echo -e "${YELLOW}üí≠ Test command unclear: $input${NC}"
                echo -e "${GRAY}Try: 'test filename.py' or 'run filename.py'${NC}"
                return 1
            fi
            ;;
    esac
    
    if [ -n "$command" ]; then
        execute_command "$command"
    else
        echo -e "${YELLOW}üí≠ Action unclear: $input${NC}"
        echo -e "${GRAY}Try: 'rename X to Y', 'copy X to Y', 'make X executable'${NC}"
    fi
}

# COMMAND HANDLERS
handle_create() {
    local filename="$1"
    local description="$2"
    
    if [ -z "$filename" ] || [ -z "$description" ]; then
        echo -e "${RED}Usage: /create <filename> <description>${NC}"
        return 1
    fi
    
    local target="$WORK_DIR/$filename"
    
    if [ -f "$target" ]; then
        echo -e -n "${YELLOW}File exists. Overwrite? (y/N): ${NC}"
        local confirm
        read -r confirm
        if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
            echo -e "${BLUE}Cancelled${NC}"
            return 0
        fi
    fi
    
    show_typing "Creating $filename"
    
    local create_prompt="Create $filename: $description. Make it complete and functional."
    local response=$(call_gemma "$create_prompt" "" "0.3")
    
    if [ -n "$response" ]; then
        local code=$(extract_code "$response")
        echo "$code" > "$target"
        
        if [ $? -eq 0 ]; then
            local lines=$(wc -l < "$target")
            echo -e "${GREEN}‚úì Created $filename ($lines lines)${NC}"
            save_to_memory "create $filename: $description" "Created $filename"
        else
            echo -e "${RED}‚úó Failed to write $filename${NC}"
        fi
    else
        echo -e "${RED}‚úó Failed to generate $filename${NC}"
    fi
}

handle_edit() {
    local filename="$1"
    # Remove any trailing whitespace from filename
    filename=$(echo "$filename" | sed 's/[[:space:]]*$//')
    local target="$WORK_DIR/$filename"

    if [ ! -f "$target" ]; then
        echo -e "${RED}‚úó File not found: $filename${NC}"
        return 1
    fi

    # Prefer $EDITOR if set
    if [ -n "$EDITOR" ] && command -v "$EDITOR" > /dev/null; then
        "$EDITOR" "$target"
    elif command -v code > /dev/null; then
        code "$target"
    elif command -v nano > /dev/null; then
        nano "$target"
    elif command -v vim > /dev/null; then
        vim "$target"
    else
        echo -e "${RED}No editor found${NC}"
        return 1
    fi

    echo -e "${GREEN}‚úì Edited $filename${NC}"
}

handle_run() {
    local filename="$1"
    # Remove any trailing whitespace from filename
    filename=$(echo "$filename" | sed 's/[[:space:]]*$//')
    local target="$filename"
    
    if [ ! -f "$target" ]; then
        echo -e "${RED}‚úó File not found: $filename${NC}"
        return 1
    fi
    
    echo -e "${BLUE}${ROCKET_ICON} Running $filename...${NC}"
    echo -e "${GRAY}‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ${NC}"
    
    # Already in current directory, no need to change
    case "$filename" in
        *.py) python3 "$filename" || python "$filename" ;;
        *.js) node "$filename" ;;
        *.sh) bash "$filename" ;;
        *.rb) ruby "$filename" ;;
        *.go) go run "$filename" ;;
        *) echo -e "${YELLOW}Unknown file type: $filename${NC}" ;;
    esac
    
    echo -e "${GRAY}‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ${NC}"
    echo -e "${GREEN}‚úì Finished${NC}"
}

handle_explain() {
    local filename="$1"
    # Remove any trailing whitespace from filename
    filename=$(echo "$filename" | sed 's/[[:space:]]*$//')
    local target="$WORK_DIR/$filename"
    
    if [ ! -f "$target" ]; then
        echo -e "${RED}‚úó File not found: $filename${NC}"
        return 1
    fi
    
    show_typing "Analyzing $filename"
    
    local code=$(cat "$target")
    local explain_prompt="Explain this code clearly and concisely:

$code"
    local response=$(call_gemma "$explain_prompt" "" "0.5")
    
    if [ -n "$response" ]; then
        echo -e "${GREEN}‚úì Explanation for $filename:${NC}"
        echo
        format_output "$response" "  "
        echo
        save_to_memory "explain $filename" "$response"
    else
        echo -e "${RED}‚úó Failed to explain $filename${NC}"
    fi
}

handle_fix() {
    local filename="$1"
    # Remove any trailing whitespace from filename
    filename=$(echo "$filename" | sed 's/[[:space:]]*$//')
    shift
    local issue="$*"
    local target="$WORK_DIR/$filename"
    
    if [ ! -f "$target" ]; then
        echo -e "${RED}‚úó File not found: $filename${NC}"
        return 1
    fi
    
    show_typing "Fixing $filename"
    
    local code=$(cat "$target")
    local fix_prompt="Fix this code to resolve: $issue

Code:
$code

Return only the complete fixed code."
    local response=$(call_gemma "$fix_prompt" "" "0.3")
    
    if [ -n "$response" ]; then
        local fixed_code=$(extract_code "$response")
        local backup_file="$target.backup.$(date +%Y%m%d_%H%M%S)"
        
        cp "$target" "$backup_file"
        echo "$fixed_code" > "$target"
        
        echo -e "${GREEN}‚úì Fixed $filename${NC}"
        echo -e "${GRAY}Backup: ${backup_file##*/}${NC}"
        save_to_memory "fix $filename: $issue" "Fixed $filename"
    else
        echo -e "${RED}‚úó Failed to fix $filename${NC}"
    fi
}

handle_files() {
    local show_dotfiles=1
    local only_sources=0
    # Parse options: --no-dotfiles, --sources
    for arg in "$@"; do
        case "$arg" in
            --no-dotfiles) show_dotfiles=0 ;;
            --sources) only_sources=1 ;;
        esac
    done

    echo -e "${BLUE}üìÑ Files in: ${WORK_DIR}${NC}"
    echo
    local file_count=0 total_lines=0
    cd "$WORK_DIR" || return
    shopt -s nullglob
    for file in * .*; do
        # Optionally skip dotfiles
        if [ $show_dotfiles -eq 0 ] && [[ "$file" == .* ]]; then
            continue
        fi
        # Optionally show only source files
        if [ $only_sources -eq 1 ] && [[ ! "$file" =~ \.(py|js|sh|rb|go|ts|c|cpp|java|rs|pl|php|lua|swift|scala|kt|cs|hs|jl|m|r|sql|json|yaml|yml|toml|ini|cfg|xml|html|css|md|txt)$ ]]; then
            continue
        fi
        if [ -f "$file" ] && [ "$file" != "." ] && [ "$file" != ".." ]; then
            local lines=$(wc -l < "$file" 2>/dev/null || echo "0")
            local size=$(stat -c%s "$file" 2>/dev/null || stat -f%z "$file" 2>/dev/null || echo "0")
            local size_str=""; [ "$size" -gt 1048576 ] && size_str="$(( size / 1048576 ))MB" || { [ "$size" -gt 1024 ] && size_str="$(( size / 1024 ))KB" || size_str="${size}B"; }
            case "$file" in
                *.py) echo -e "  üêç ${GREEN}${file}${NC} ${GRAY}(${lines} lines, ${size_str})${NC}" ;;
                *.js) echo -e "  üìú ${YELLOW}${file}${NC} ${GRAY}(${lines} lines, ${size_str})${NC}" ;;
                *.txt) echo -e "  üìÑ ${WHITE}${file}${NC} ${GRAY}(${lines} lines, ${size_str})${NC}" ;;
                *.md) echo -e "  üìù ${BLUE}${file}${NC} ${GRAY}(${lines} lines, ${size_str})${NC}" ;;
                *.sh) echo -e "  ‚ö° ${GREEN}${file}${NC} ${GRAY}(${lines} lines, ${size_str})${NC}" ;;
                .*) echo -e "  üîí ${GRAY}${file}${NC} ${GRAY}(${lines} lines, ${size_str})${NC}" ;;
                *) echo -e "  üìÑ ${WHITE}${file}${NC} ${GRAY}(${lines} lines, ${size_str})${NC}" ;;
            esac
            ((file_count++)); ((total_lines += lines))
        fi
    done
    shopt -u nullglob
    echo; echo -e "${GRAY}üìä Total: ${file_count} files, ${total_lines} lines${NC}"
    if [ $show_dotfiles -eq 1 ]; then
        echo -e "${GRAY}Tip: Use '/files --no-dotfiles' to hide dotfiles.${NC}"
    fi
    if [ $only_sources -eq 0 ]; then
        echo -e "${GRAY}Tip: Use '/files --sources' to show only source/code files.${NC}"
    fi
}

handle_status() {
    echo -e "${BLUE}üì° Status${NC}"
    echo -e "${CYAN}Model:${NC} ${MODEL_NAME}"
    if [ "$API_PROVIDER" = "openrouter" ]; then
        local provider_label="${PROVIDER_NAME:-auto}"
        echo -e "${CYAN}Provider:${NC} ${provider_label}"
    fi
    if [ -n "$PROFILE_NAME" ]; then
        echo -e "${CYAN}Profile:${NC} ${PROFILE_NAME}"
    fi
    echo -e "${CYAN}Directory:${NC} ${WORK_DIR}"
    echo -e "${CYAN}Endpoint:${NC} ${GEMMA_ENDPOINT}"
    if test_endpoint "$GEMMA_ENDPOINT" "$API_PROVIDER"; then
        echo -e "${GREEN}‚úì Endpoint reachable${NC}"
    else
        echo -e "${RED}‚úó Endpoint unreachable${NC}"
    fi
}

handle_doctor() {
    echo -e "${BLUE}ü©∫ Diagnostics${NC}"

    local issues=0
    local warnings=0
    local missing=()

    command -v curl > /dev/null || missing+=("curl")
    command -v jq > /dev/null || missing+=("jq")

    if [ ${#missing[@]} -gt 0 ]; then
        echo -e "${RED}‚úó Missing dependencies: ${missing[*]}${NC}"
        issues=$((issues + 1))
    else
        echo -e "${GREEN}‚úì Dependencies available (curl, jq)${NC}"
    fi

    if [ -d "$WORK_DIR" ]; then
        echo -e "${GREEN}‚úì Working directory: $WORK_DIR${NC}"
    else
        echo -e "${RED}‚úó WORK_DIR not found: $WORK_DIR${NC}"
        issues=$((issues + 1))
    fi

    if [ -f "$WORK_DIR/.env" ]; then
        echo -e "${GREEN}‚úì Project .env detected${NC}"
    elif [ -f "$HOME/.cody_env" ]; then
        echo -e "${GREEN}‚úì User .cody_env detected${NC}"
    else
        echo -e "${YELLOW}‚ö†Ô∏è  No .env or ~/.cody_env found${NC}"
        warnings=$((warnings + 1))
    fi

    if [ "$API_PROVIDER" = "openrouter" ]; then
        if [ -n "$OPENROUTER_API_KEY" ]; then
            echo -e "${GREEN}‚úì OpenRouter API key configured${NC}"
        else
            echo -e "${RED}‚úó OPENROUTER_API_KEY not set${NC}"
            issues=$((issues + 1))
        fi
        local provider_label="${PROVIDER_NAME:-auto}"
        echo -e "${CYAN}Provider:${NC} ${provider_label}"
    fi

    if test_endpoint "$GEMMA_ENDPOINT" "$API_PROVIDER"; then
        echo -e "${GREEN}‚úì Endpoint reachable: $GEMMA_ENDPOINT${NC}"
    else
        echo -e "${RED}‚úó Endpoint unreachable: $GEMMA_ENDPOINT${NC}"
        issues=$((issues + 1))
    fi

    if [ -n "$MEMORY_FILE" ]; then
        local memory_dir
        memory_dir=$(dirname "$MEMORY_FILE")
        if [ -e "$MEMORY_FILE" ]; then
            if [ -w "$MEMORY_FILE" ]; then
                echo -e "${GREEN}‚úì Memory file writable: $MEMORY_FILE${NC}"
            else
                echo -e "${RED}‚úó Memory file not writable: $MEMORY_FILE${NC}"
                issues=$((issues + 1))
            fi
        elif [ -d "$memory_dir" ] && [ -w "$memory_dir" ]; then
            echo -e "${GREEN}‚úì Memory file directory writable: $memory_dir${NC}"
        else
            echo -e "${RED}‚úó Memory file directory not writable: $memory_dir${NC}"
            issues=$((issues + 1))
        fi
    fi

    if [ "$issues" -eq 0 ] && [ "$warnings" -eq 0 ]; then
        echo -e "${GREEN}‚úì Diagnostics passed${NC}"
        return 0
    fi

    if [ "$issues" -eq 0 ]; then
        echo -e "${YELLOW}‚ö†Ô∏è  Diagnostics completed with ${warnings} warning(s)${NC}"
        return 0
    fi

    echo -e "${RED}‚úó Diagnostics found ${issues} issue(s)${NC}"
    return 1
}

handle_chat() {
    local input="$1"
    
    if is_action_request "$input"; then
        echo -e "${BLUE}${TARGET} Action: $input${NC}"
        execute_action "$input"
    else
        show_typing "Thinking"
        
        local response=$(call_gemma "$input")
        
        if [ -n "$response" ]; then
            echo -e "${BLUE}${ROBOT} Cody:${NC}"
            echo
            format_output "$response" "  "
            echo
            save_to_memory "$input" "$response"
        else
            echo -e "${RED}‚úó No response${NC}"
        fi
    fi
}

handle_profile() {
    local action="$1"
    shift || true
    case "$action" in
        list|"")
            list_profiles
            ;;
        use)
            load_profile "$1"
            ;;
        save)
            save_profile "$1"
            ;;
        delete)
            delete_profile "$1"
            ;;
        show)
            show_profile "$1"
            ;;
        *)
            echo -e "${YELLOW}Usage: /profile list|use|save|delete|show [name]${NC}"
            ;;
    esac
}

handle_agent() {
    local action="$1"
    shift || true
    case "$action" in
        list|"")
            agent_list
            ;;
        create)
            local name="$1"
            shift || true
            agent_create "$name" "$*"
            ;;
        show)
            agent_show "$1"
            ;;
        spawn)
            local name="$1"
            shift || true
            agent_spawn "$name" "$*"
            ;;
        stop)
            local name="$1"
            shift || true
            agent_stop "$name" "$1"
            ;;
        logs)
            agent_logs "$1"
            ;;
        delete)
            agent_delete "$1"
            ;;
        *)
            echo -e "${YELLOW}Usage: /agent list|create|show|spawn|stop|logs|delete${NC}"
            ;;
    esac
}

# MAIN INPUT PARSER
parse_input() {
    local input="$1"

    if [ -z "$input" ]; then
        return 0
    fi

    if [[ "$input" =~ ^/[a-zA-Z] ]]; then
        local command=$(echo "$input" | sed 's/^\/\([a-zA-Z]*\).*/\1/')
        local args=$(echo "$input" | sed 's/^\/[a-zA-Z]* *//')

        case "$command" in
            "create")
                local filename=$(echo "$args" | awk '{print $1}')
                local description=$(echo "$args" | cut -d' ' -f2-)
                handle_create "$filename" "$description"
                ;;
            "edit") handle_edit "$args" ;;
            "run") handle_run "$args" ;;
            "explain") handle_explain "$args" ;;
            "fix")
                local filename=$(echo "$args" | awk '{print $1}')
                local issue=$(echo "$args" | cut -d' ' -f2-)
                handle_fix "$filename" "$issue"
                ;;
            "files")
                # Allow /files --no-dotfiles and /files --sources
                handle_files $args
                ;;
            "exec") execute_command "$args" ;;
            "pip") run_pip_command "$args" ;;
            "npm") run_npm_command "$args" ;;
            "pnpm") run_pnpm_command "$args" ;;
            "yarn") run_yarn_command "$args" ;;
            "selfmod") modify_self "$args" ;;
            "model") select_model ;;
            "provider") select_provider ;;
            "status") handle_status ;;
            "doctor") handle_doctor ;;
            "reload")
                load_system_prompt
                echo -e "${GREEN}‚úì System prompt reloaded${NC}"
                ;;
            "profile") handle_profile $args ;;
            "agent") handle_agent $args ;;
            "wizard") run_onboarding_wizard ;;
            "clear")
                > "$MEMORY_FILE"
                echo -e "${YELLOW}‚úì Cleared${NC}"
                ;;
            "help") print_help "$args" ;;
            "exit"|"quit")
                echo -e "${YELLOW}${ROCKET_ICON} Goodbye!${NC}"
                exit 0
                ;;
            *)
                echo -e "${RED}Unknown: /$command${NC}"
                ;;
        esac
    else
        handle_chat "$input"
    fi
}

# MAIN LOOP
main() {
    trap 'echo -e "\n${YELLOW}Goodbye!${NC}"; exit 0' INT
    trap 'print_header' WINCH

    # Check if we're running non-interactively (piped input)
    if [ ! -t 0 ]; then
        # Non-interactive mode: read from stdin and process each line
        while IFS= read -r input; do
            parse_input "$input"
        done
        exit 0
    fi

    setup_readline
    print_header

    while true; do
        printf "${GREEN}‚ùØ${NC} "  # More distinct prompt with a space
        input=$(read_input_enhanced)

        # ESC pressed: cancel and return to prompt
        if [[ "$input" == "__CODY_ESC__" ]] || [ $? -eq 130 ]; then
            echo -e "${YELLOW}‚Ü©Ô∏è  Cancelled. Back to prompt.${NC}"
            echo -e "${GRAY}‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ${NC}"  # Divider after cancel
            continue
        fi

        if [ $? -ne 0 ]; then
            echo -e "\n${YELLOW}Goodbye!${NC}"
            break
        fi

        parse_input "$input"
        echo -e "${GRAY}‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ${NC}"  # Divider after each command
        echo  # Blank line for readability
    done
}

# STARTUP
# Check if we're running non-interactively (piped input)
if [ ! -t 0 ]; then
    # Non-interactive mode: minimal startup
    if ! ensure_dependencies; then
        exit 1
    fi
    
    load_model_preference
    load_provider_preference
    load_profile_preference
    load_system_prompt
    validate_work_dir
    select_endpoint
    
    # Quick connection test
    if ! test_endpoint "$GEMMA_ENDPOINT" "$API_PROVIDER"; then
        exit 1
    fi
    
    main
else
    # Interactive mode: full startup
    echo -e "${CYAN}üöÄ Self-Modifying Cody${NC}"
    echo -e "${GRAY}Initializing...${NC}"

    # Check dependencies
    if ! ensure_dependencies; then
        exit 1
    fi

    # Load configuration
    load_model_preference
    load_provider_preference
    load_profile_preference
    load_system_prompt
    validate_work_dir
    run_onboarding_wizard
    select_endpoint

    echo -e "${BLUE}Testing connection...${NC}"
    if ! test_endpoint "$GEMMA_ENDPOINT" "$API_PROVIDER"; then
        exit 1
    fi

    echo -e "${GREEN}‚úì Connected${NC}"
    select_model

    sleep 1
    main
fi
